// Generated by CoffeeScript 1.12.7
(function() {
  var DifferentialIncident, LocationTree, _, convertAllIncidentsToDifferentials, convertAllIncidentsToDifferentialsSingleDisease, countryISOToGeoname, regionToCountries;

  LocationTree = require('./LocationTree');

  regionToCountries = require('../regionToCountries.json');

  countryISOToGeoname = require('../countryISOToGeoname.json');

  DifferentialIncident = require('./DifferentialIncident');

  _ = require('underscore');

  convertAllIncidentsToDifferentials = function(incidents, replaceRegionsWithCountries) {
    var diseases, result;
    if (replaceRegionsWithCountries == null) {
      replaceRegionsWithCountries = true;
    }
    result = [];
    diseases = _.chain(incidents).map(function(x) {
      var ref;
      return (ref = x.resolvedDisease) != null ? ref.id : void 0;
    }).uniq().value();
    diseases.forEach(function(disease) {
      var diseaseMatch;
      diseaseMatch = function(x) {
        var ref;
        return ((ref = x.resolvedDisease) != null ? ref.id : void 0) === disease;
      };
      return result = result.concat(convertAllIncidentsToDifferentialsSingleDisease(incidents.filter(diseaseMatch), replaceRegionsWithCountries));
    });
    return result;
  };

  convertAllIncidentsToDifferentialsSingleDisease = function(incidents, replaceRegionsWithCountries) {
    var cumulativeIncidents, differentialIncidents;
    cumulativeIncidents = [];
    differentialIncidents = [];
    if (replaceRegionsWithCountries) {
      incidents.forEach(function(incident) {
        var locations, ref;
        if (!((ref = incident.locations) != null ? ref.length : void 0)) {
          return;
        }
        locations = [];
        incident.locations.forEach(function(location) {
          if (regionToCountries[location.id]) {
            return regionToCountries[location.id].countryISOs.forEach(function(iso) {
              console.assert(countryISOToGeoname[iso]);
              return locations.push(countryISOToGeoname[iso]);
            });
          } else {
            return locations.push(location);
          }
        });
        return incident.locations = locations;
      });
    }
    incidents.forEach(function(incident) {
      var ref, simpleIncident;
      if (!incident.dateRange) {
        return;
      }
      if (((ref = incident.type) === 'activeCount' || ref === 'specify') || incident.specify) {
        return;
      }
      simpleIncident = new DifferentialIncident(incident);
      if (!simpleIncident.count) {
        return;
      }
      if (incident.dateRange.cumulative) {
        return cumulativeIncidents.push(simpleIncident);
      } else {
        return differentialIncidents.push(simpleIncident);
      }
    });
    _.chain(cumulativeIncidents).sortBy("endDate").groupBy(function(i) {
      return i.type + "," + ((i != null ? i.locations : void 0) || []).map(function(l) {
        return l.id;
      }).sort();
    }).forEach(function(incidentGroup, b) {
      var countDifference, incident, j, len, newDifferential, nextIncident, prevIncident, ref, ref1, results;
      incidentGroup = incidentGroup.reduce(function(sofar, incident) {
        var dateDiff, prevIncident;
        if (sofar.length === 0) {
          return [incident];
        }
        prevIncident = sofar.slice(-1)[0];
        dateDiff = Number(incident.endDate) - Number(prevIncident.endDate);
        if (dateDiff > 0) {
          return sofar.concat(incident);
        } else if (dateDiff === 0) {
          if (prevIncident.count >= incident.count) {
            return sofar;
          } else {
            return sofar.slice(0, -1).concat(incident);
          }
        } else {
          throw Error("endDates are not sorted.");
        }
      }, []);
      prevIncident = incidentGroup[0];
      ref = _.zip(incidentGroup.slice(1), incidentGroup.slice(2));
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], incident = ref1[0], nextIncident = ref1[1];
        countDifference = incident.count - prevIncident.count;
        if (countDifference < 0) {
          if (nextIncident && nextIncident.count < prevIncident.count) {
            prevIncident = incident;
          }
          continue;
        }
        newDifferential = new DifferentialIncident({
          type: incident.type,
          locations: incident.locations,
          cumulative: incident.cumulative,
          count: countDifference,
          startDate: prevIncident.endDate,
          endDate: incident.endDate,
          originalIncidents: prevIncident.originalIncidents.concat(incident.originalIncidents)
        });
        prevIncident = incident;
        results.push(differentialIncidents.push(newDifferential));
      }
      return results;
    });
    return differentialIncidents;
  };

  module.exports = convertAllIncidentsToDifferentials;

}).call(this);
