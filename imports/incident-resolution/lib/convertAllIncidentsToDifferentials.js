// Generated by CoffeeScript 1.12.7
(function() {
  var DifferentialIncident, LocationTree, MILLIS_PER_DAY, _, convertAllIncidentsToDifferentials, convertAllIncidentsToDifferentialsSingleDisease, countryISOToGeoname, regionToCountries;

  LocationTree = require('./LocationTree');

  regionToCountries = require('../regionToCountries.json');

  countryISOToGeoname = require('../countryISOToGeoname.json');

  _ = require('underscore');

  MILLIS_PER_DAY = 1000 * 60 * 60 * 24;

  DifferentialIncident = (function() {
    function DifferentialIncident(incident) {
      var j, len, prop, properties;
      properties = ['startDate', 'endDate', 'count', 'type', 'locations', 'cumulative', 'originalIncidents'];
      if (properties.every(function(p) {
        return p in incident;
      })) {
        for (j = 0, len = properties.length; j < len; j++) {
          prop = properties[j];
          this[prop] = incident[prop];
        }
      } else {
        this.startDate = new Date(incident.dateRange.start);
        this.startDate.setUTCHours(0);
        this.startDate.setUTCMinutes(0);
        this.startDate.setUTCSeconds(0);
        this.startDate.setUTCMilliseconds(0);
        this.endDate = new Date(incident.dateRange.end);
        this.endDate.setUTCMinutes(70);
        this.endDate.setUTCHours(0);
        this.endDate.setUTCMinutes(0);
        this.endDate.setUTCSeconds(0);
        this.endDate.setUTCMilliseconds(0);
        if (this.startDate > this.endDate) {
          console.log(incident);
          throw new Error("Invalid incident: Dates out of order.");
        } else if (Number(this.startDate) === Number(this.endDate) && !incident.dateRange.cumulative) {
          this.endDate.setUTCDate(this.endDate.getUTCDate() + 1);
        }
        this.count = incident.cases || incident.deaths;
        this.type = _.keys(_.pick(incident, 'cases', 'deaths'))[0];
        this.locations = LocationTree.from(incident.locations || []).children.map(function(x) {
          return x.value;
        });
        this.cumulative = incident.dateRange.cumulative;
        this.originalIncidents = [incident];
      }
      this.initialize();
    }

    DifferentialIncident.prototype.initialize = function() {
      var ref;
      this.duration = (Number(this.endDate) - Number(this.startDate)) / MILLIS_PER_DAY;
      this.rate = this.count / this.duration / this.locations.length;
      this.diseaseId = (ref = this.originalIncidents[0].resolvedDisease) != null ? ref.id : void 0;
      return this;
    };

    DifferentialIncident.prototype.truncated = function(dateRange) {
      var newDuration, newEndDate, newStartDate;
      newStartDate = new Date(this.startDate);
      newEndDate = new Date(this.endDate);
      if (this.startDate < dateRange.start) {
        newStartDate = new Date(dateRange.start);
      }
      if (this.endDate > dateRange.end) {
        newEndDate = new Date(dateRange.end);
      }
      newDuration = (Number(newEndDate) - Number(newStartDate)) / MILLIS_PER_DAY;
      return this.clone({
        startDate: newStartDate,
        endDate: newEndDate,
        count: this.count * newDuration / this.duration
      });
    };

    DifferentialIncident.prototype.clone = function(extendProps) {
      var clonedIncident;
      if (extendProps == null) {
        extendProps = {};
      }
      clonedIncident = Object.create(this);
      _.extend(clonedIncident, extendProps);
      return clonedIncident.initialize();
    };

    return DifferentialIncident;

  })();

  convertAllIncidentsToDifferentials = function(incidents, replaceRegionsWithCountries) {
    var diseases, result;
    if (replaceRegionsWithCountries == null) {
      replaceRegionsWithCountries = true;
    }
    result = [];
    diseases = _.chain(incidents).map(function(x) {
      var ref;
      return (ref = x.resolvedDisease) != null ? ref.id : void 0;
    }).uniq().value();
    diseases.forEach(function(disease) {
      var diseaseMatch;
      diseaseMatch = function(x) {
        var ref;
        return ((ref = x.resolvedDisease) != null ? ref.id : void 0) === disease;
      };
      return result = result.concat(convertAllIncidentsToDifferentialsSingleDisease(incidents.filter(diseaseMatch), replaceRegionsWithCountries));
    });
    return result;
  };

  convertAllIncidentsToDifferentialsSingleDisease = function(incidents, replaceRegionsWithCountries) {
    var cumulativeIncidents, differentialIncidents;
    cumulativeIncidents = [];
    differentialIncidents = [];
    if (replaceRegionsWithCountries) {
      incidents.forEach(function(incident) {
        var locations, ref;
        if (!((ref = incident.locations) != null ? ref.length : void 0)) {
          return;
        }
        locations = [];
        incident.locations.forEach(function(location) {
          if (regionToCountries[location.id]) {
            return regionToCountries[location.id].countryISOs.forEach(function(iso) {
              console.assert(countryISOToGeoname[iso]);
              return locations.push(countryISOToGeoname[iso]);
            });
          } else {
            return locations.push(location);
          }
        });
        return incident.locations = locations;
      });
    }
    incidents.forEach(function(incident) {
      var ref, simpleIncident;
      if (!incident.dateRange) {
        return;
      }
      if (((ref = incident.type) === 'activeCount' || ref === 'specify') || incident.specify) {
        return;
      }
      simpleIncident = new DifferentialIncident(incident);
      if (!simpleIncident.count) {
        return;
      }
      if (incident.dateRange.cumulative) {
        return cumulativeIncidents.push(simpleIncident);
      } else {
        return differentialIncidents.push(simpleIncident);
      }
    });
    _.chain(cumulativeIncidents).sortBy("endDate").groupBy(function(i) {
      return i.type + "," + ((i != null ? i.locations : void 0) || []).map(function(l) {
        return l.id;
      }).sort();
    }).forEach(function(incidentGroup, b) {
      var countDifference, incident, j, len, newDifferential, nextIncident, prevIncident, ref, ref1, results;
      incidentGroup = incidentGroup.reduce(function(sofar, incident) {
        var dateDiff, prevIncident;
        if (sofar.length === 0) {
          return [incident];
        }
        prevIncident = sofar.slice(-1)[0];
        dateDiff = Number(incident.endDate) - Number(prevIncident.endDate);
        if (dateDiff > 0) {
          return sofar.concat(incident);
        } else if (dateDiff === 0) {
          if (prevIncident.count >= incident.count) {
            return sofar;
          } else {
            return sofar.slice(0, -1).concat(incident);
          }
        } else {
          throw Error("endDates are not sorted.");
        }
      }, []);
      prevIncident = incidentGroup[0];
      ref = _.zip(incidentGroup.slice(1), incidentGroup.slice(2));
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], incident = ref1[0], nextIncident = ref1[1];
        countDifference = incident.count - prevIncident.count;
        if (countDifference < 0) {
          if (nextIncident && nextIncident.count < prevIncident.count) {
            prevIncident = incident;
          }
          continue;
        }
        newDifferential = new DifferentialIncident({
          type: incident.type,
          locations: incident.locations,
          cumulative: incident.cumulative,
          count: countDifference,
          startDate: prevIncident.endDate,
          endDate: incident.endDate,
          originalIncidents: prevIncident.originalIncidents.concat(incident.originalIncidents)
        });
        prevIncident = incident;
        results.push(differentialIncidents.push(newDifferential));
      }
      return results;
    });
    return differentialIncidents;
  };

  module.exports = convertAllIncidentsToDifferentials;

}).call(this);
