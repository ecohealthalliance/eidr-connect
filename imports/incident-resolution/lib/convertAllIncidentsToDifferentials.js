// Generated by CoffeeScript 1.12.7
(function() {
  var DifferentialIncident, LocationTree, SortedIncidentSequence, _, computeOptimalCumulativeIncidentSequence, computeSimpleCumulativeIncidentSequence, convertAllIncidentsToDifferentials, convertAllIncidentsToDifferentialsSingleDisease, countryISOToGeoname, regionToCountries;

  LocationTree = require('./LocationTree');

  regionToCountries = require('../regionToCountries.json');

  countryISOToGeoname = require('../countryISOToGeoname.json');

  DifferentialIncident = require('./DifferentialIncident');

  _ = require('underscore');

  convertAllIncidentsToDifferentials = function(incidents, replaceRegionsWithCountries) {
    var diseases, result;
    if (replaceRegionsWithCountries == null) {
      replaceRegionsWithCountries = true;
    }
    result = [];
    diseases = _.chain(incidents).map(function(x) {
      var ref;
      return (ref = x.resolvedDisease) != null ? ref.id : void 0;
    }).uniq().value();
    diseases.forEach(function(disease) {
      var diseaseMatch;
      diseaseMatch = function(x) {
        var ref;
        return ((ref = x.resolvedDisease) != null ? ref.id : void 0) === disease;
      };
      return result = result.concat(convertAllIncidentsToDifferentialsSingleDisease(incidents.filter(diseaseMatch), replaceRegionsWithCountries));
    });
    return result;
  };

  SortedIncidentSequence = (function() {
    function SortedIncidentSequence(finalIncident, priorIncidentSeq) {
      var valueDifference;
      this.finalIncident = finalIncident;
      this.priorIncidentSeq = priorIncidentSeq != null ? priorIncidentSeq : null;
      this.finalCount = this.finalIncident.count;
      this.score = 1;
      if (this.priorIncidentSeq) {
        this.score = this.priorIncidentSeq.score;
        valueDifference = this.finalCount - this.priorIncidentSeq.finalCount;
        if (valueDifference < 0) {
          this.score -= 4;
        } else {
          this.score += 1;
        }
      }
    }

    SortedIncidentSequence.prototype.concat = function(newIncident) {
      return new SortedIncidentSequence(newIncident, this);
    };

    SortedIncidentSequence.prototype.getIncidents = function() {
      if (this.priorIncidentSeq) {
        return this.priorIncidentSeq.getIncidents().concat(this.finalIncident);
      } else {
        return [this.finalIncident];
      }
    };

    return SortedIncidentSequence;

  })();

  computeOptimalCumulativeIncidentSequence = function(cumulativeIncidents) {
    var incidentSeqsSortedByScore;
    incidentSeqsSortedByScore = [];
    cumulativeIncidents.forEach(function(cumulativeIncident) {
      var extendedIncidentSeq, finalCount, greaterIncidentSeq, greaterIncidentSeqIndex, greaterIncidentSeqs, incidentSeq, index, j, k, len, len1, lesserIncidentSeqs, noSmallerIncident, oneIfEqual, ref, resetIncidentSeq;
      noSmallerIncident = true;
      ref = _.range(incidentSeqsSortedByScore.length);
      for (j = 0, len = ref.length; j < len; j++) {
        index = ref[j];
        incidentSeq = incidentSeqsSortedByScore[index];
        finalCount = incidentSeq.finalCount;
        if (cumulativeIncident.count >= finalCount) {
          oneIfEqual = cumulativeIncident.count === finalCount ? 1 : 0;
          greaterIncidentSeqs = incidentSeqsSortedByScore.slice(0, index);
          lesserIncidentSeqs = incidentSeqsSortedByScore.slice(index + oneIfEqual);
          extendedIncidentSeq = incidentSeq.concat(cumulativeIncident);
          resetIncidentSeq = incidentSeqsSortedByScore[0].concat(cumulativeIncident);
          if (extendedIncidentSeq.score < resetIncidentSeq.score) {
            extendedIncidentSeq = resetIncidentSeq;
          }
          greaterIncidentSeqIndex = 0;
          for (k = 0, len1 = greaterIncidentSeqs.length; k < len1; k++) {
            greaterIncidentSeq = greaterIncidentSeqs[k];
            if (greaterIncidentSeq.score < extendedIncidentSeq.score) {
              break;
            }
            greaterIncidentSeqIndex += 1;
          }
          incidentSeqsSortedByScore = greaterIncidentSeqs.slice(0, greaterIncidentSeqIndex).concat([extendedIncidentSeq]).concat(lesserIncidentSeqs);
          noSmallerIncident = false;
          break;
        }
      }
      if (noSmallerIncident) {
        return incidentSeqsSortedByScore = incidentSeqsSortedByScore.concat([new SortedIncidentSequence(cumulativeIncident)]);
      }
    });
    return incidentSeqsSortedByScore[0].getIncidents();
  };

  computeSimpleCumulativeIncidentSequence = function(incidentGroup) {
    var countDifference, incident, j, len, nextIncident, prevIncident, ref, ref1, result;
    prevIncident = incidentGroup[0];
    result = [prevIncident];
    ref = _.zip(incidentGroup.slice(1), incidentGroup.slice(2));
    for (j = 0, len = ref.length; j < len; j++) {
      ref1 = ref[j], incident = ref1[0], nextIncident = ref1[1];
      countDifference = incident.count - prevIncident.count;
      if (countDifference < 0) {
        if (nextIncident && nextIncident.count < prevIncident.count) {
          null;
        } else {
          continue;
        }
      }
      result.push(incident);
      prevIncident = incident;
    }
    return result;
  };

  convertAllIncidentsToDifferentialsSingleDisease = function(incidents, replaceRegionsWithCountries) {
    var cumulativeIncidents, differentialIncidents;
    cumulativeIncidents = [];
    differentialIncidents = [];
    if (replaceRegionsWithCountries) {
      incidents.forEach(function(incident) {
        var locations, ref;
        if (!((ref = incident.locations) != null ? ref.length : void 0)) {
          return;
        }
        locations = [];
        incident.locations.forEach(function(location) {
          if (regionToCountries[location.id]) {
            return regionToCountries[location.id].countryISOs.forEach(function(iso) {
              console.assert(countryISOToGeoname[iso]);
              return locations.push(countryISOToGeoname[iso]);
            });
          } else {
            return locations.push(location);
          }
        });
        return incident.locations = locations;
      });
    }
    incidents.forEach(function(incident) {
      var ref, simpleIncident;
      if (!incident.dateRange) {
        return;
      }
      if (((ref = incident.type) === 'activeCount' || ref === 'specify') || incident.specify) {
        return;
      }
      simpleIncident = new DifferentialIncident(incident);
      if (!simpleIncident.count) {
        return;
      }
      if (incident.dateRange.cumulative) {
        return cumulativeIncidents.push(simpleIncident);
      } else {
        return differentialIncidents.push(simpleIncident);
      }
    });
    _.chain(cumulativeIncidents).sortBy("endDate").groupBy(function(i) {
      return i.type + "," + ((i != null ? i.locations : void 0) || []).map(function(l) {
        return l.id;
      }).sort();
    }).forEach(function(incidentGroup, b) {
      var countDifference, filteredCumulateIncidents, incident, j, len, newDifferential, prevIncident, ref, ref1, results;
      incidentGroup = incidentGroup.reduce(function(sofar, incident) {
        var dateDiff, prevIncident;
        if (sofar.length === 0) {
          return [incident];
        }
        prevIncident = sofar.slice(-1)[0];
        dateDiff = Number(incident.endDate) - Number(prevIncident.endDate);
        if (dateDiff > 0) {
          return sofar.concat(incident);
        } else if (dateDiff === 0) {
          if (prevIncident.count >= incident.count) {
            return sofar;
          } else {
            return sofar.slice(0, -1).concat(incident);
          }
        } else {
          throw Error("endDates are not sorted.");
        }
      }, []);
      filteredCumulateIncidents = computeOptimalCumulativeIncidentSequence(incidentGroup);
      ref = _.zip(filteredCumulateIncidents.slice(0, -1), filteredCumulateIncidents.slice(1));
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        ref1 = ref[j], prevIncident = ref1[0], incident = ref1[1];
        countDifference = incident.count - prevIncident.count;
        if (countDifference >= 0) {
          newDifferential = new DifferentialIncident({
            type: incident.type,
            locations: incident.locations,
            cumulative: incident.cumulative,
            count: countDifference,
            startDate: prevIncident.endDate,
            endDate: incident.endDate,
            originalIncidents: prevIncident.originalIncidents.concat(incident.originalIncidents)
          });
          results.push(differentialIncidents.push(newDifferential));
        } else {
          results.push(void 0);
        }
      }
      return results;
    });
    return differentialIncidents;
  };

  module.exports = convertAllIncidentsToDifferentials;

}).call(this);
